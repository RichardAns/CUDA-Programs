// Programming in Parallel with CUDA - supporting code by Richard Ansorge 
// copyright 2021 is licensed under CC BY-NC 4.0 for non-commercial use
// This code may be freely changed but please retain an acknowledgement

// chapter 8 readspot 
// This is a support program for chapter 8 PET simualtion
// This code does not use the GPU and is not discussed in detail in the book.
// The program reads the spots files generated by fullsim (example 8.6) and creates the 
// system matrix file used by the reco program (examples 8.7 & 8.8)

#include "cx.h"
#include "cxtimers.h"
#include "cxbinio.h"
#include "scanner.h"

#include "vector_types.h"
#include <random>
#include <vector>

bool hitsort_z1z2(const Hit &lhs,const Hit &rhs) {

	// < means accending  i.e 00 comes before 01
	if(lhs.getkey() < rhs.getkey()) return true;
	return false;
}

bool hitsort_val(const Hit &lhs,const Hit &rhs) {

	// < means accending  i.e 00 comes before 01
	if(lhs.val() < rhs.val()) return true;
	return false;
}

// The optional logs files are for debugging as give information about individual lors.
//
// slog:  gives full details for every lor in (z1,c1) order.
// mlog:  a more compact version of slog giving just spot statitics.
// vlog:  list all lors remaining after wcut in key order
// wlog:  all lors sorted by acending by number of hits with a per ring cumulative total. Useful for tuning wcut.


int main(int argc,char* argv[])
{
	if(argc <2){
		printf("usage readspot <spot file head> <sm file> <voxref1|0> <voxref2|99> wcut|0.1 zcut|63 dologs|0 verbose|0\n");
		return 0;
	}

	int voxref1  = (argc>3) ? atoi(argv[3]) : 0;
	int voxref2  = (argc>4) ? atoi(argv[4]) : 99;
	double wcut  = (argc>5) ? atof(argv[5]) : 0.1;
	int zcut     = (argc>6) ? atoi(argv[6]) : zNum-1;
	int dologs   = (argc>7) ? atoi(argv[7]) : 0;
	int verbose  = (argc>8) ? atoi(argv[8]) : 0;

	int slice        = spotNphi*spotNz;
	size_t bigslice  = zNum*cryNum;
	size_t size      = bigslice*slice;
	std::vector<uint> spot(size);

	// save hit numbers in seperate file <nfiles> <total hits> f0-hits ... fn_hits
	std::vector<uint> nhits(voxref2-voxref1+1+2);

	std::vector<smTab> tab(voxref2-voxref1+1);
	tab[0].start = 0;
	nhits[0] = voxref2-voxref1+1;
	uint nhits_total = 0;

	char name[256];  // for (short!) output file names	
	auto newlog = [&name](const char *tag,int &v){sprintf(name,"%s_%3.3d.log",tag,v); return fopen(name,"w");};

	for(int vox = voxref1;vox <= voxref2;vox++){ // loop over spot files (one for each voxel ring)
		// these log files are for debugging and are verbose.
		FILE *slog = (dologs>0) ? newlog("slog",vox) : nullptr;
		FILE *mlog = (dologs>0) ? newlog("mlog",vox) : nullptr;
		FILE *vlog = (dologs>0) ? newlog("vlog",vox) : nullptr;
		FILE *wlog = (dologs>0) ? newlog("wlog",vox) : nullptr;

		// this for smtab
		int kv = vox-voxref1;
		if(kv>0)tab[kv].start = tab[kv-1].end;
		tab[kv].ring = vox;
		tab[kv].phi_steps = cryNum;

		sprintf(name,"%s%3.3d.raw",argv[1],vox);
		if(cx::read_raw(name,spot.data(),size,1)) { printf("bad read on %s\n",name); return 1; }
		uint good = 0;
		uint bad = 0;
		size_t sl = 0;
		unsigned long long sum_sum = 0;
		unsigned long long sum_lors = 0;
		uint lmax_max = 0;
		std::vector<Hit> hits;
		unsigned long long sum_1 = 0;  // this for log histgram  of counts per lor
		unsigned long long sum_10 = 0;
		unsigned long long sum_100 = 0;
		unsigned long long sum_1000 = 0;
		unsigned long long sum_10000 = 0;
		unsigned long long sum_100000 = 0;
		unsigned long long sum_1000000 = 0;
		for(int z1 = 0;z1<zNum;z1++) for(int c1=0;c1<cryNum;c1++){
			Lor l = {z1,c1,0,0};           //***** new version z1 = zms1
			uint lors = 0;
			uint lmax = 0;
			uint lmin = 4000000000; // 4 10^9 ceiling on lor values

			// get tile position and clear values
			int z0 =spot[sl];           spot[sl] = 0;
			int c0 = spot[sl+spotNphi]; spot[sl+spotNphi] = 0;

			unsigned long long slice_sum = 0;
			for(int z=0;z<spotNz;z++) for(int c=0;c<spotNphi;c++) {  // loop over spot image
				uint val = spot[sl+z*spotNphi+c];
				if(val < 1) continue;
				l.z2 = z+z0;
				l.c2 = (c+c0)%cryNum;  // NB might rotate 399->0
				// dz and dc cuts here
				if(abs(l.c1-l.c2) > cryDiffMax || abs(l.c1-l.c2) < cryDiffMin || (l.z1+l.z2) >= (int)zcut) continue;

				slice_sum += val;
				lors++;
				lmax = std::max(lmax,val);
				lmin = std::min(lmin,val);
				Hit h(l,(float)val); // here we store hit
				hits.push_back(h);
				if(dologs)fprintf(slog,"  lor %2d (%2.2d-%3.3d) (%2.2d-%3.3d) %8.0f\n",lors,l.z1,l.c1,l.z2,l.c2,(double)val);
				if(val > 1000000)     sum_1000000++;
				else if(val > 100000) sum_100000++;
				else if(val > 10000)  sum_10000++;
				else if(val > 1000)   sum_1000++;
				else if(val > 100)    sum_100++;
				else if(val > 10)     sum_10++;
				else                  sum_1++;
			} // end (z2,c2) loop
			sum_sum += slice_sum;
			sum_lors += lors;
			lmax_max = std::max(lmax_max,lmax);  
			(slice_sum > 0) ? good++ : bad++;
			if(lors > 0 && dologs){
				fprintf(slog,"slice %2.2d-%3.3d hits %llu lors %d max %u min %u\n",z1,c1,slice_sum,lors,lmax,lmin);
				fprintf(mlog,"slice %2.2d-%3.3d hits %llu lors %d max %u min %u\n",z1,c1,slice_sum,lors,lmax,lmin);
			}
			sl += slice;
		}  // end (z1,c1) loop

		if(verbose)printf("grand sum %llu good slices %d bad %d sum_lors %llu maxlor %u\n",sum_sum,good,bad,sum_lors,lmax_max);
		if(verbose)printf("sums %llu %llu %llu %llu %llu %llu %llu\n",sum_1000000,sum_100000,sum_10000,sum_1000,sum_100,sum_10,sum_1);
		if(verbose)printf("Hits file has %llu lors\n",hits.size());
		size_t csize = hits.size();

		// This to drop lors with few hits. Probable lors may have 10^5 hits so it makes little sense to keep lors
		// with say 2 hits. We sort the lors by number of hits and cut the with tail of low counts. The parameter wcuts 
		// is the percentage of the total numner of hits for this ring which is dropped. 
		// The default for wcut is 0.1%  which is very small, cuts of 30% or more seem to have litte effect
		// on reconstuction accuracy.

		long long clumsum = 0;
		double clumfrac = 0.0;
		long long clumcut = 0;
		float clumcut_val = 0.0f;
		std::sort<Hit *>(hits.data(),hits.data()+csize,hitsort_val);
		if(wcut > 0.0){
			for(size_t i=0;i<hits.size();i++){
				Lor l = hits[i].key_to();
				clumsum += (long long)hits[i].val();
				clumfrac = 100.0*(double)clumsum/(double)sum_sum;
				if(wcut > 0.0 && clumfrac >= wcut && clumcut==0) { clumcut = i; clumcut_val = hits[i].val(); }
				if(dologs)fprintf(wlog,"slice %7lld (%2.2d-%3.3d) (%2.2d-%3.3d) %.0f %lld %.3f\n",i,l.z1,l.c1,l.z2,l.c2,hits[i].val(),clumsum,clumfrac);
			}

			size_t clumcut_size = hits.size()-clumcut;
			for(size_t j=0;j<clumcut_size;j++) hits[j] = hits[j+clumcut];
			hits.resize(clumcut_size);
			if(verbose)printf("wcut at %.0f reduced size from %lld to %llu lors\n",clumcut_val,csize,hits.size());
			csize = hits.size();
		}


		// Here we  resort the lors into increasing z1/z2 order. This is an important optimisation for 
		// the reco code which is written to address memory efficintly assuming this sorting order.

		std::sort<Hit *>(hits.data(),hits.data()+csize,hitsort_z1z2);
		for(size_t i=0;i<hits.size();i++){
			Lor l = hits[i].key_to();
			if(dologs)fprintf(vlog,"lor %6lld (%2.2d-%3.3d) (%2.2d-%3.3d) %.0f\n",i,l.z1,l.c1,l.z2,l.c2,hits[i].val());
		}

		// Here we add this ring to new system matrix
		nhits[vox-voxref1+2] = (uint)hits.size();
		if(vox == voxref1) cx::write_raw(argv[2],hits.data(),hits.size());
		else               cx::append_raw(argv[2],hits.data(),hits.size());
		nhits_total += (uint)hits.size();
		tab[kv].end = (uint)hits.size() + tab[kv].start;

		if(dologs){ fclose(slog); fclose(mlog); fclose(vlog); fclose(wlog); }
	}  // end spotfile loop

	nhits[1] = nhits_total;
	sprintf(name,"hits_rings%3.3d-%3.3d.raw",voxref1,voxref2);   // needed for normalisaton of sm contents per ring
	sprintf(name,"smtab_rings%3.3d-%3.3d.raw",voxref1,voxref2);  // needed to index rings within full sm
	cx::write_raw(name,tab.data(),tab.size());

	

#if 0  
	// this to check new smfile is what we expect for one record 
	uint cksize = nhits[2];
	printf("check cksize = %d\n",cksize);
	std::vector<Hit> chits(cksize);
	//sprintf(name,"hits%3.3d.raw",voxref1);
	cx::read_raw(argv[2],chits.data(),cksize);
	Lor cl = chits[100].key_to();
	float v = chits[100].val();
	uint k = chits[100].getkey();
	printf("key %d %8.8x\n",100,k);
	printf("check lor %2d (%2.2d-%3.3d) (%2.2d-%3.3d) %8.0f\n",100,cl.z1,cl.c1,cl.z2,cl.c2,v);
#endif
	printf("size of sm_file %d rings %d records\n",nhits[0],nhits[1]);
	return 0;
}
